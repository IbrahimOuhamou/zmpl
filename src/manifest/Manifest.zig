const std = @import("std");
const builtin = @import("builtin");

const util = @import("util.zig");

allocator: std.mem.Allocator,
templates_path: []const u8,
template_paths: [][]const u8,

pub const Version = enum { v1, v2 };

const Manifest = @This();

const TemplateDef = struct {
    key: []const u8,
    name: []const u8,
    content: []const u8,
    partial: bool,
};

pub fn init(allocator: std.mem.Allocator, templates_path: []const u8, template_paths: [][]const u8) Manifest {
    return .{
        .allocator = allocator,
        .templates_path = templates_path,
        .template_paths = template_paths,
    };
}

pub fn compile(
    self: *Manifest,
    version: Version,
    comptime TemplateType: type,
    comptime options: type,
) ![]const u8 {
    var template_defs = std.ArrayList(TemplateDef).init(self.allocator);

    try self.compileTemplates(&template_defs, TemplateType, options);

    var buf = std.ArrayList(u8).init(self.allocator);
    const writer = buf.writer();
    defer buf.deinit();

    try writer.writeAll(
        \\// Zmpl template manifest.
        \\// This file is automatically generated at build time and should not be manually modified.
        \\
        \\const std = @import("std");
        \\const __zmpl = @import("zmpl");
        \\
    );

    for (template_defs.items) |template_def| {
        try writer.writeAll(try std.fmt.allocPrint(self.allocator,
            \\
            \\{s}
            \\
        , .{template_def.content}));
    }

    try writer.writeAll(try std.fmt.allocPrint(self.allocator,
        \\
        \\pub const ZmplValue = __zmpl.Data.Value;
        \\pub const __Manifest = struct {{
        \\    pub const version: enum {{ v1, v2 }} = .{s};
        \\
        \\    pub const Template = struct {{
        \\       name: []const u8,
        \\       render: __zmpl.Data.RenderFn,
        \\       renderWithLayout: *const fn(Template, *__zmpl.Data) anyerror![]const u8,
        \\    }};
        \\
        \\    pub fn find(name: []const u8) ?Template {{
        \\        return template_map.get(name);
        \\    }}
        \\
    , .{@tagName(version)}));

    for (template_defs.items) |template_def| {
        if (template_def.partial) continue;

        try writer.writeAll(try std.fmt.allocPrint(self.allocator,
            \\const {0s} = __Manifest.Template{{
            \\  .render = {0s}_render,
            \\  .renderWithLayout = {s}_renderWithLayout,
            \\  .name = "{0s}",
            \\}};
        , .{template_def.name}));
    }

    try writer.writeAll(
        \\    pub const template_map = std.ComptimeStringMap(
        \\        Template,
        \\        .{
        \\
    );

    for (template_defs.items) |template_def| {
        if (template_def.partial) continue;

        try writer.writeAll(try std.fmt.allocPrint(
            self.allocator,
            \\.{{ "{s}", {s} }},
            \\
        ,
            .{ template_def.key, template_def.name },
        ));
    }

    try writer.writeAll(
        \\        }
        \\    );
        \\};
        \\
    );
    return self.allocator.dupe(u8, buf.items);
}

fn compileTemplates(
    self: *Manifest,
    array: *std.ArrayList(TemplateDef),
    comptime TemplateType: type,
    comptime options: type,
) !void {
    var template_map = std.StringHashMap([]const u8).init(self.allocator);

    for (self.template_paths) |path| {
        const generated_name = try util.generateVariableNameAlloc(self.allocator);
        const key = try util.templatePathStore(self.allocator, self.templates_path, path);
        try template_map.put(key, generated_name);
    }

    for (self.template_paths) |path| {
        const key = try util.templatePathStore(self.allocator, self.templates_path, path);
        const generated_name = template_map.get(key).?;

        var file = try std.fs.openFileAbsolute(path, .{});
        const size = (try file.stat()).size;
        const content = try file.readToEndAlloc(self.allocator, size);
        var template = TemplateType.init(
            self.allocator,
            generated_name,
            self.templates_path,
            path,
            content,
            template_map,
        );
        const partial = template.partial;
        const output = try template.compile(options);

        const template_def: TemplateDef = .{
            .key = key,
            .name = generated_name,
            .content = output,
            .partial = partial,
        };

        try array.append(template_def);
    }
    std.debug.print("[zmpl] Compiled {} template(s)\n", .{self.template_paths.len});
}
